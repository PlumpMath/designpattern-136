# 装饰者模式

### 设计原则
- 类应该对扩展开放，对修改关闭。（新代码易增加，旧代码不改变）
这个原则通常很难在每一个部分做到，这样反而会让代码变得复杂和难以理解。
我们应该把注意力放在最有可能改变的地方。然后，应用这个原则。

### 关键
- 装饰者对象和被装饰对象有相同的超类型。
- 你可以用一个或者多个装饰者包装一个对象。
- 因为有相同的超类型，所以可以在任何需要原始对象(被包装的)的场合，用装饰过的对象代替它。
- **装饰者可以在所委托被装饰者的行为之前与之后，加上自己的行为，以达到特定的目的**
- 对象可以在任何时候被装饰， 所以可以在运行时动态地、 不限量地用你喜欢的装饰者来装饰对象。

### 装饰者模式定义
```sh
Headfirst: 装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承
更加有弹性的替代方案。
```

### 具体应用
java.io包中的
```sh
    Component        :  InputStream
    ConcreteComponent:  FileInputStream   StringBufferInputStream   ByteArrayInputStream
    Decorater        :  FilterInputStream
    ConcreteComponent:  PushbackInputStream  BufferedInputStream  DataInputStream  LineNumberInputStream
```

### 缺点（个人理解）
装饰者模式的缺点，恰恰指明了不该使用的场景
- 会造成大量的小类，每一个装饰者都需要来个新的类（不过这个可以被熟悉装饰者模式的人理解）。
- 一旦使用装饰者装饰，那么会把自己的类型变没，转为一个父类对象，自己的方法没的调用了。（不能依赖于特定的类型）
- 单单使用装饰者模式，在使用装饰者实例化组件的时候，将增加代码的复杂度。很难明确清晰的层。