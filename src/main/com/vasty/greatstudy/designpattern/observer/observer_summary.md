# 观察者模式

### 设计原则
- 松耦合

### 报社的例子
```sh
1. 只要有订阅，报社一有更新，就给你送报纸。
2. 取消订阅后，就不会给你送报纸。
3. 报社运营过程中，会不断有人取消或者订阅
```
所以， **报社就是Subject， 而订阅者就是observer**
### 观察者模式定义
```sh
HeadFirst定义： 观察者模式定义了一对多依赖， 这样一来， 只要一个对象状态改变的时候，它
的所有依赖者都会受到通知，并且自动更新。
```
### 观察者模式实现
实现方式不只一种  

- 包含Subject和Observer接口的设计最为常见。 

### 观察者模式的松耦合
对于主题来说， 只知道观察者实现了某个接口。 有新的观察者出现的时候， 主题的代码不需要改变。
当有观察者退出的时候，主题的代码依然不需要改变。

### java.util包中的例子
- Observable 类
  
    * 这个类中的change属性的作用在于， 可以设置真正需要更新的时间点(例如 温度的变化非常频繁，只有在真正
      需要更新的时候，改变这个属性的值即可
- Observer   接口
    * update(Observable o, Object args);           
    这样的方式，可以使得观察者知道是哪个主题发回的通知，以及通知的内容

### 拉与推
push 版本，会把所有的数据 直接在update()中塞给你
pull 版本，则是在update()中通知你数据改变了， 并且Subject提供了诸多方法来获取数据。 
对于Observer来说，被调用到了update()方法后，再去寻找自己需要的数据。
但是， 推的方式被认为更加正确